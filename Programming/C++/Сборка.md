![[Pasted image 20250728011930.png]]

## Препроцессор

![[Pasted image 20250728012130.png]]

Препроцессор - 1 стадия сборки программы.

Можно явно вызывать g++ -E main.cpp -o main.ii

Удаляет комментарии копипастом подставляет макросы.

![[Pasted image 20250727184551.png]]
многострочный макрос

По аккуратнее с инкрементами в макросах! может быть 2 увеличение!

## Ошибка на этапе препроцессора

```cpp
#error "unknown config например"
```

можно через флаги препроцессора определять макросы

## Как макросом из чего угодно сделать строку


```cpp
	#definge STRINGIFY(TOKEN) #TOKEN
```

## Теперь в char

```cpp
#definge STRINGIFY(TOKEN) #@TOKEN
```

## Конкатенация

```cpp
#define CONCAT(a,b) a##b
```

![[Pasted image 20250727192855.png]]


```cpp
__LINE__
// номер строчки на которой он был добавлен
__FILE__ 
// аналогично с названием файла
__DATE__
__TIME__
```


С угловыми скобками препроцессор ищет в директориях переменных окружения и системных.
С кавычками - где текущий, подкаталогах и где укажешь.

![[Pasted image 20250727195003.png]]

## Стек макросов

```cpp
#pragma warning (disable : 4507)
// выключить ворнинг
```



## Компиляция

![[Pasted image 20250728011707.png]]
![[Pasted image 20250728013313.png]]
![[Pasted image 20250728011524.png]]
![[Pasted image 20250728011828.png]]
![[Pasted image 20250728013136.png]]



![[Pasted image 20250728015812.png]]




## Оптимизация

![[Pasted image 20250728215943.png]]


на линуксе что б дебажить одновременно с++ и asm код:

```cpp
gdb -tui ./programm
```

![[Pasted image 20250728235743.png]]

выравнивание по 8 байтов

## Линкер

![[Pasted image 20250731015503.png]]

Почему хедерами пользуются и лучше всего использовать forward declaration? Препроцессор копируют реализацию класса в каждый cpp файл, то есть каждый изменяется и каждый должен быть перекомпилирован.

![[Pasted image 20250731022950.png]]
Forward declaration для классов.
Его нужно использовать, что б потом в не перекомпилировать файлы.

Если в вашем классе Character в заголовочном файле (header) вы используете только указатель или ссылку на класс Weapon, то **действительно достаточно сделать forward declaration в хедере** и включить полный заголовок Weapon.h в cpp-файле (реализации). Это стандартная и предпочтительная практика в C++ по нескольким причинам:

- Включение полного заголовка Weapon.h в хедер Character.h приводит к более **жёсткой связности** между модулями — при изменении Weapon.h потребуется перекомпилировать все, кто включает Character.h.

```cpp
# <iosfwd> // более короткий вариант iostream
```

##  Прекомпилированные заголовки

Для ускорения сборки, что нужно:

- Создай хэдр и вставь в него все #include, а откуда взял, удали.
- Создай cpp файл и включи в него хэдр.
- Компилируй указывая заголовочный и спп файл (загугли опцию компилятора)
- Используй его вместо заголочных
- Дальше просто компилируешь все файлы, добавляя ЗАГОЛОВОЧНЫЙ файл с определенным флагом.

**В 3 раза быстрее!!!**

Изменения касаются только заголовочных и тех, что от них зависят!

При изменение заголовочных перекомпилируется pch, но не при cpp.

Unity-build - это когда несколько с++ файлов обьединяются в 1 и компилируются разом.

Только это не будет работать, если у тебя есть несколько внутренних функций в разный файлах, static например.

## Статические библиотеки


Статические библиотеки - это сборник объектных файлов.

![[Pasted image 20250802235251.png]]


## Динамическая библиотека

![[Pasted image 20250803000924.png]]

![[Pasted image 20250803001106.png]]

В dll нужно явно указывать, какие функции будут импортироваться и экспортироваться.
![[Pasted image 20250803003221.png]]

---
tags:
  - cpp
изучил?: false
создал заметку: 
описание:
---

### Концепты

**Основные языковые понятия:**
- `same_as` — указывает на то, что два типа одинаковы.
- `derived_from` — указывает на то, что один тип является производным от другого.
- `convertible_to` — указывает на то, что тип неявно преобразуется в другой тип.
- `common_with` — указывает на то, что два типа имеют общий тип.
- `integral` — указывает на то, что тип является целочисленным.
- `default_constructible` — указывает на то, что объект данного типа может быть создан по умолчанию.
**Концепции сравнения:**
- `boolean` — указывает на то, что тип можно использовать в логических контекстах.
- `equality_comparable` — указывает на то, что `operator==` является отношением эквивалентности.
**Объектные концепции:**
- `movable` — указывает на то, что объект данного типа можно перемещать и менять местами.
- `copyable` — указывает на то, что объект данного типа можно копировать, перемещать и менять местами.
- `semiregular` — указывает на то, что объект данного типа можно копировать, перемещать, менять местами и создавать по умолчанию.
- `regular` — указывает на то, что тип является _обычным_, то есть он одновременно и `semiregular`, и `equality_comparable`.
**Вызываемые понятия:**
- `invocable` — указывает на то, что вызываемый тип может быть вызван с заданным набором типов аргументов.
- `predicate` — указывает на то, что вызываемый тип является логическим предикатом.


### std::format 

```cpp
std::format("{1} {0}", "world", "hello"); // == "hello world"

int x = 123;
std::string str = std::format("x: {}", x); // str == "x: 123"

// Format to an output iterator:
for (auto x : {1, 2, 3}) {
  std::format_to(std::ostream_iterator<char>{std::cout, "\n"}, "{}", x);
}
```

Свои типы:

```c
struct fraction {
  int numerator;
  int denominator;
};

template <>
struct std::formatter<fraction>
{
    constexpr auto parse(std::format_parse_context& ctx) {
      return ctx.begin();
    }

    auto format(const fraction& f, std::format_context& ctx) const {
      return std::format_to(ctx.out(), "{0:d}/{1:d}", f.numerator, f.denominator);
    }
};

fraction f{1, 2};
std::format("{}", f); // == "1/2"
```

### Синхронизированный буферный выходной поток

Буферы выводят операции для обернутого выходного потока, обеспечивая синхронизацию (то есть отсутствие чередования вывода).

```c
std::osyncstream{std::cout} << "Значение x равно:" << x 
<< std::endl;
```

### std::span
Спэн — это представление (т. е. не являющееся владельцем) контейнера, обеспечивающее доступ к смежной группе элементов с проверкой границ. Поскольку представления не являются владельцами своих элементов, их создание и копирование не требуют больших затрат. Упрощённо можно представить, что представления содержат ссылки на свои данные. Вместо того чтобы хранить указатель/итератор и поле длины, спэн объединяет их в одном объекте.

Интервалы могут быть динамическими или фиксированными (известными как _extent_). Интервалы с фиксированным размером позволяют проверять границы.

Span не поддерживает const, поэтому для создания диапазона только для чтения используйте `std::span<const T>`.

Пример: использование диапазона с динамическим размером для вывода целых чисел из различных контейнеров.

```c
print_ints void(std::span<const int> ints) {
 for (const auto n : ints) {
 std::cout << n << std::endl;
 }
}

print_ints(std::vector{ 1, 2, 3 });
print_ints(std::array<int, 5>{ 1, 2, 3, 4, 5 });
int a[10] = { 0 };
print_ints(a);
// и т. д.
```

### Битовые операции

В C++20 появился новый заголовок `<bit>` с некоторыми побитовыми операциями, включая popcount.

```c
std::popcount(0u); // 0
std::popcount(1u); // 1
std::popcount(0b1111'0000u); // 4
```

### Математические константы

Математические константы, включая число Пи, число Эйлера и т. д., определены в заголовке `<numbers>`

```c
std::numbers::pi; // 3,14159...
std::numbers::e; // 2,71828...
```

### std::make_shared поддерживает массивы

```c
auto p = std::make_shared<int[]>(5); // указатель на `int[5]`
// ИЛИ
auto p = std::make_shared<int[5]>(); // указатель на `int[5]`
```

### starts_with и ends_with для строк

Строки (и представления строк) теперь имеют функции-члены `starts_with` и `ends_with` для проверки того, начинается ли строка с заданной строки или заканчивается ею.

```c
std::string str = "foobar";
str.starts_with("foo"); // true
str.ends_with("baz"); // false
```

### Проверьте, есть ли в ассоциативном контейнере элемент

Ассоциативные контейнеры, такие как множества и карты, имеют функцию-член `contains`, которую можно использовать вместо идиомы «найти и проверить конец итератора».

```c
std::map<int, char> map {{1, 'a'}, {2, 'b'}};
map.contains(2); // true
map.contains(123); // false

std::set<int> set {1, 2, 3};
set.contains(2); // true
```

### std::to_array

Преобразует заданный массив/объект, похожий на массив, в `std::array`.

```c
std::to_array("foo"); // возвращает `std::array<char, 4>`
std::to_array<int>({1, 2, 3}); // возвращает `std::array<int, 3>`

int a[] = {1, 2, 3};
std::to_array(a); // возвращает `std::array<int, 3>`
```

### Равномерное стирание контейнера

Предоставляет `std::erase` и/или `std::erase_if` для различных контейнеров STL, таких как string, list, vector, map и т. д.

Для удаления по значению используйте `std::erase`, а для указания предиката, по которому будут удаляться элементы, используйте `std::erase_if`. Обе функции возвращают количество удалённых элементов.

```c
std::vector v{0, 1, 0, 2, 0, 3};
std::erase(v, 0); // v == {1, 2, 3}
std::erase_if(v, [](int n) { return n == 0; }); // v == {1, 2, 3}
```

### Трехстороннее сравнение


В C++20 появился оператор-космический корабль (`<=>`) — новый способ написания функций сравнения, который сокращает количество шаблонных кода и помогает разработчикам определять более чёткую семантику сравнения. При определении трёхстороннего оператора сравнения автоматически генерируются другие функции операторов сравнения (например, == !=, <, и т. д.).

Представлены три варианта заказа:

- `std::strong_ordering`: Строгий порядок различает товары, являющиеся равными (идентичными и взаимозаменяемыми). Обеспечивает `less`, `greater`, `equivalent`, и `equal` упорядочивание. Примеры сравнений: поиск определенного значения в списке, значения целых чисел, строки с учетом регистра.
- `std::weak_ordering`Слабый порядок позволяет различать элементы, которые являются эквивалентными (не идентичными, но взаимозаменяемыми в целях сравнения). Обеспечивает `less`-, `greater`- и `equivalent`-упорядочивание. Примеры сравнения: строки без учёта регистра, сортировка, сравнение некоторых, но не всех видимых членов класса.
- `std::partial_ordering`Частичный порядок подчиняется тому же принципу слабого порядка, но включает в себя случай, когда порядок невозможен. Обеспечивает порядок `less`, `greater`, `equivalent`, и `unordered` . Примеры сравнения: значения с плавающей запятой (например, `NaN`).

Трёхсторонний оператор сравнения по умолчанию выполняет поэлементное сравнение:

```c
foo struct {
 int a;
 bool b;
 char c;

 // Сначала сравниваем `a`, затем `b`, потом `c` ...
  friend auto operator<=>(const foo&) const = default;
};

foo f1{0, false, 'a'}, f2{0, true, 'b'};
f1 < f2; // == true
f1 == f2; // == false
f1 >= f2; // == false
```

Вы также можете задать собственные параметры сравнения:

```c
foo struct {
 int x;
 bool b;
 char c;

 friend std::strong_ordering operator<=>(const foo& other) const {
 return x <=> other.x;
 }
};

foo f1{0, false, 'a'}, f2{0, true, 'b'};
f1 < f2; // == false
f1 == f2; // == true
f1 >= f2; // == true
```

### Назначенные инициализаторы

Синтаксис инициализации в стиле C. Все поля-члены, которые явно не указаны в списке инициализации, инициализируются по умолчанию.

```c
A struct {
 int x;
 int y;
 int z = 123;
};

A a {.x = 1, .z = 2}; // a.x == 1, a.y == 0, a.z == 2
```

### Цикл for на основе диапазона с инициализатором

Эта функция упрощает распространённые шаблоны написания кода, помогает сократить объём кода и предлагает элегантное решение распространённой проблемы, связанной с жизненным циклом.

```c
for (auto v = std::vector{1, 2, 3}; auto& e : v) {
 std::cout << e;
}
// выводит "123"
```

### вероятные и маловероятные атрибуты

Подсказывает оптимизатору, что помеченный оператор с высокой вероятностью будет выполнен.

```c
switch (n) {
case 1:
 // ...
  break;

[[likely]] case 2: // n == 2 считается более
  // ... // вероятным, чем любое другое значение n
  break;
}
```

Если один из атрибутов likely/unlikely стоит после правой скобки в операторе if, это означает, что в ветви с высокой вероятностью будет выполнен её подвыражение (тело).

```c
int random = get_random_number_between_x_and_y(0, 3);
if (random > 0) [[вероятно]] {
 // тело оператора if
  // ...
}
```

Его также можно применить к подвыражению (телу) итерационного выражения.

```c
while (маловероятно_правдивое_условие) [[маловероятно]] {
 //тело цикла while
  // ...
}
```

### Не рекомендуется неявное сохранение этого

Неявное использование `this` в лямбда-выражении с использованием `[=]` теперь не рекомендуется. Вместо этого используйте явное указание `[=, this]` или `[=, *this]`.

```c
int_value struct {
 int n = 0;
 auto getter_fn() {
 // ПЛОХО:
    // return [=]() { return n; };

    // ХОРОШО:
    return [=, *this]() { return n; };
 }
};
```


### виртуальные функции constexpr

Виртуальные функции теперь можно создавать `constexpr` и оценивать во время компиляции. `constexpr` виртуальные функции могут переопределять невиртуальные функции `constexpr` и наоборот.

```c
X1 struct {
 virtual int f() const = 0;
};

struct X2: public X1 {
 constexpr virtual int f() const { return 2; }
};

struct X3: public X2 {
 virtual int f() const { return 3; }
};

struct X4: public X3 {
 constexpr virtual int f() const { return 4; }
};

constexpr X4 x4;
x4.f(); // == 4
```

### char8_t

Предоставляет стандартный тип для представления строк в кодировке UTF-8.

```c
char8_t utf8_str[] = u8"\u0123";
```


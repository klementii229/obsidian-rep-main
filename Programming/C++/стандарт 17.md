### std::variant

```cpp
std::variant<int, double> v{ 12 };
std::get<int>(v); // == 12
std::get<0>(v); // == 12
v = 12.0;
std::get<double>(v); // == 12.0
std::get<1>(v); // == 12.0
```

- **Размер объекта равен размеру самого большого из типов** плюс небольшой служебный индекс, указывающий активный тип[3](https://habr.com/ru/articles/804837/).
- Обеспечивает **безопасный доступ к значению** через функции `std::get<T>`, `std::get_if<T>`, и проверку типа через `std::holds_alternative<T>`[6](https://learn.microsoft.com/ru-ru/cpp/standard-library/variant-functions?view=msvc-170).

### std::optional

```cpp
#include <iostream>
#include <optional>

std::optional<std::string> createMessage(bool create) {
    if (create) {
        return "Hello, World!";
    } else {
        return std::nullopt;
    }
}

int main() {
    auto message = createMessage(true);
    if (message.has_value()) {
        std::cout << message.value() << '\n';
    } else {
        std::cout << "No message created.\n";
    }
    return 0;
}
```

### std::any
`std::any` — это тип из C++, который позволяет хранить значения произвольного типа. В отличие от `std::variant`, где типы должны быть заранее определены, `std::any` может хранить значение любого типа, что делает его очень гибким.

```cpp
#include <any>

int main() {
    std::any a = 42;
    if (a.has_value()) {
        try {
            int value = std::any_cast<int>(a);
            std::cout << "Value: " << value << '\n';
        } catch (const std::bad_any_cast& e) {
            std::cerr << "Error: " << e.what() << '\n';
        }
    }
    return 0;
}
```

**Никаких неявных сужений!!!**
### std::string_view

```cpp
// Regular strings.
std::string_view cppstr {"foo"};
// Wide strings.
std::wstring_view wcstr_v {L"baz"};
// Character arrays.
char array[3] = {'b', 'a', 'r'};
std::string_view array_v(array, std::size(array));
```


### std::invoke
`std::invoke` — это утилита, представленная в C++17, которая предоставляет унифицированный способ вызова различных видов вызываемых объектов. Она позволяет вызывать функции, указатели на функции, функциональные объекты и другие вызываемые сущности с использованием одного интерфейса.

```cpp
#include <iostream>
#include <functional>
void hello() {
    std::cout << "Hello, World!" << '\n';
}

struct Greeter {
    void operator()(const std::string& name) const {
        std::cout << "Hello, " << name << "!" << '\n';
    }
};

int main() {
    std::invoke(hello);
    // Вызов функтора
    std::invoke(Greeter{}, "Alice");
    return 0;
}
```
### std::apply
`std::apply` — это функция, представленная в C++17, которая позволяет вызывать вызываемый объект (например, функцию) с аргументами, извлеченными из кортежа. Это особенно удобно, когда у вас есть кортеж, содержащий аргументы функции, и вы хотите передать их в функцию.

```cpp
#include <iostream>
#include <tuple>
#include <functional>
// Пример функции, которую мы будем вызывать
void printSum(int a, int b, int c) {
    std::cout << "Sum: " << a + b + c << '\n';
}

int main() {
    // Создаем кортеж с аргументами
    auto args = std::make_tuple(1, 2, 3);

    // Используем std::apply для передачи этих аргументов в функцию
    std::apply(printSum, args);
    return 0;
}
```


### std::filesystem
`std::filesystem` — это библиотека, представленная в C++17, которая предоставляет кроссплатформенный интерфейс для работы с файловой системой. Она позволяет выполнять различные операции с файлами и директориями, такие как создание, удаление, копирование, перемещение и проверка их свойств.

```cpp
#include <iostream>
#include <filesystem>
#include <fstream>

namespace fs = std::filesystem;

int main() {
    fs::path filePath = "example.txt";
    fs::path dirPath = "example_dir";
    // Проверяем существование файла и создаем его, если его нет
    if (!fs::exists(filePath)) {
        std::ofstream(filePath);
        std::cout << "File created.\n";
    }
    // Проверяем существование директории и создаем её, если её нет
    if (!fs::exists(dirPath)) {
        fs::create_directory(dirPath);
        std::cout << "Directory created.\n";
    }
    // Удаляем файл
    fs::remove(filePath);
    std::cout << "File removed.\n";

    return 0;
}
```

### std::byte
`std::byte` — это тип, представленный в C++17, предназначенный для работы с байтами. Он обеспечивает типобезопасную работу с сырыми данными и помогает избежать проблем, связанных с использованием `char` или `unsigned char` для работы с байтовыми данными.

```cpp
#include <iostream>
#include <cstddef> // Для std::byte
int main() {
    std::byte b1{0x3F}; // Создаем байт с шестнадцатеричным значением 0x3F
    std::byte b2{0x0F};

    // Применяем побитовые операции
    std::byte result = b1 & b2; // Побитовое И

    // Выводим результат как целое число
    std::cout << "Result: " << std::to_integer<int>(result) << '\n';

    return 0;
}

```

### Splicing for maps and sets

```cpp
Moving elements from one map to another:

```c
std::map<int, string> src {{1, "one"}, {2, "two"}, {3, "buckle my shoe"}};
std::map<int, string> dst {{3, "three"}};
dst.insert(src.extract(src.find(1))); // Cheap remove and insert of { 1, "one" } from `src` to `dst`.
dst.insert(src.extract(2)); // Cheap remove and insert of { 2, "two" } from `src` to `dst`.
// dst == { { 1, "one" }, { 2, "two" }, { 3, "three" } };
```

Inserting an entire set:

```c
std::set<int> src {1, 3, 5};
std::set<int> dst {2, 4, 5};
dst.merge(src);
// src == { 5 }
// dst == { 1, 2, 3, 4, 5 }
```

Inserting elements which outlive the container:

```c
auto elementFactory() {
  std::set<...> s;
  s.emplace(...);
  return s.extract(s.begin());
}
s2.insert(elementFactory());
```

Changing the key of a map element:

```c
std::map<int, string> m {{1, "one"}, {2, "two"}, {3, "three"}};
auto e = m.extract(2);
e.key() = 4;
m.insert(std::move(e));
// m == { { 1, "one" }, { 3, "three" }, { 4, "two" } }
```


### Параллельные алгоритмы

Многие алгоритмы STL, такие как методы `copy`, `find` и `sort`, начали поддерживать _политики параллельного выполнения_: `seq`, `par` и `par_unseq`, которые соответствуют «последовательному», «параллельному» и «параллельному без упорядочивания» режимам.

```cpp

```
### std::sample
`std::sample` — это функция, представленная в C++17, которая используется для случайного выбора элементов из диапазона. Она полезна, когда нужно получить случайную подвыборку из большого набора данных.
```cpp
#include <iostream>
#include <vector>
#include <algorithm>
#include <random>

int main() {
    std::vector<int> v = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    std::vector<int> sampled(3); // Буфер для сохранения выбранных элементов

    std::random_device rd;
    std::mt19937 g(rd());

    // Выбираем 3 случайных элемента из вектора v и сохраняем их в sampled
    std::sample(v.begin(), v.end(), sampled.begin(), 3, g);

    // Выводим выбранные элементы
    for (int elem : sampled) {
        std::cout << elem << ' ';
    }
    std::cout << '\n';

    return 0;
}

```

### std::clamp
`std::clamp` — это функция, представленная в C++17, которая ограничивает значение в заданном диапазоне. Если значение меньше нижней границы, оно устанавливается равным этой границе. Если значение больше верхней границы, оно устанавливается равным этой верхней границе. Если значение находится в пределах диапазона, оно остаётся неизменным.

```cpp
#include <iostream>
#include <algorithm> // Для std::clamp

int main() {
    int value = 10;
    int low = 5;
    int high = 8;

    int clamped_value = std::clamp(value, low, high);

    std::cout << "Clamped value: " << clamped_value << '\n'; // Выведет 8

    return 0;
}
```
### std::reduce
`std::reduce` — это алгоритм, представленный в C++17, который используется для выполнения операции свертки на диапазоне элементов. Он объединяет элементы диапазона в одно значение с помощью заданной операции.

```cpp
#include <iostream>
#include <vector>
#include <numeric> // Для std::reduce

int main() {
    std::vector<int> v = {1, 2, 3, 4, 5};

    // Суммируем элементы вектора
    int sum = std::reduce(v.begin(), v.end());

    std::cout << "Sum: " << sum << '\n'; // Выведет 15 (1+2+3+4+5)

    // Используем начальное значение
    int sum_with_init = std::reduce(v.begin(), v.end(), 10);

    std::cout << "Sum with init: " << sum_with_init << '\n'; // Выведет 25 (10+1+2+3+4+5)

    // Используем пользовательскую операцию (умножение)
    auto multiply = [](int a, int b) { return a * b; };
    int product = std::reduce(v.begin(), v.end(), 1, multiply);

    std::cout << "Product: " << product << '\n'; // Выведет 120 (1*2*3*4*5)

    return 0;
}
```

### НОД и НОК

Наибольший общий делитель (НОД) и наименьшее общее кратное (НОК).

```cpp
int const p = 9;
const int q = 3;
std::gcd(p, q); // == 3
std::lcm(p, q); // == 9
```

### Функции округления для временных промежутков и точек времени
Предоставляет вспомогательные функции abs, round, ceil и floor для `std::chrono::duration` и `std::chrono::time_point`.

```c
using seconds = std::chrono::seconds;
std::chrono::milliseconds d{ 5500 };
std::chrono::abs(d); // == 5 с
std::chrono::round<seconds>(d); // == 6 с
std::chrono::ceil<seconds>(d); // == 6 с
std::chrono::floor<seconds>(d); // == 5 с
```

## Возможности языка


### Объявление параметров шаблона, не относящихся к типу, с помощью auto

В соответствии с правилами вывода `auto` и с учётом списка допустимых типов[*] не являющихся параметрами шаблона, аргументы шаблона могут быть выведены из типов его аргументов:

```c
template <auto... seq>
struct my_integer_sequence {
 // Реализация здесь ...
};

// Явно передайте тип `int` в качестве аргумента шаблона.
auto seq = std::integer_sequence<int, 0, 1, 2>();
// Тип выведен как `int`.
auto seq2 = my_integer_sequence<0, 1, 2>();
```

* Например, вы не можете использовать `double` в качестве типа параметра шаблона, что также делает этот вывод с использованием `auto` недопустимым.

### Folding expressions

Складные выражения

Свёрточное выражение выполняет свёртку пакета параметров шаблона с помощью бинарного оператора.

- Выражения вида `(... op e)` или `(e op ...)`, где `op` — оператор свёртки, а `e` — неразвёрнутый пакет параметров, называются _унарными свёртками_.
- Выражение вида `(e1 op ... op e2)`, где `op` — операторы свёртки, называется _бинарной свёрткой_. Либо `e1`, либо `e2` являются неразвёрнутыми пакетами параметров, но не оба сразу.

```cpp
template <typename... Args>
auto sum(Args... args) {
    // Unary folding.
    return (... + args);
}
sum(1.0, 2.0f, 3); // == 6.0
```

### лямбда - выражение constexpr
Лямбда-выражения во время компиляции с использованием `constexpr`.

```c
auto identity = [](int n) constexpr { return n; };
static_assert(identity(123) == 123);
```

```c
auto constexpr add = [](int x, int y) {
 auto L = [=] { return x; };
 auto R = [=] { return y; };
 return [=] { return L() + R(); };
};

static_assert(add(1, 2)() == 3);
```

```c
addOne int constexpr(int n) {
 return [n] { return n + 1; }();
}

static_assert(addOne(1) == 2);
```

### Лямбда-захват `this` по значению

Ранее при захвате `this` в среде лямбда-выражения использовалась только ссылка. Примером проблемной ситуации может служить асинхронный код с использованием обратных вызовов, для которых требуется, чтобы объект был доступен, даже если срок его жизни истек. `*this` (C++17) теперь создает копию текущего объекта, в то время как `this` (C++11) продолжает захватывать объект по ссылке.

```c
MyObj struct {
 int value {123};
 auto getValueCopy() {
 return [*this] { return value; };
 }
 auto getValueRef() {
 return [this] { return value; };
 }
};
MyObj mo;
auto valueCopy = mo.getValueCopy();
auto valueRef = mo.getValueRef();
mo.value = 321;
valueCopy(); // 123
valueRef(); // 321
```

### Встроенные переменные

Ключевое слово inline может применяться как к переменным, так и к функциям. Переменная, объявленная с ключевым словом inline, имеет ту же семантику, что и функция, объявленная с ключевым словом inline.

```c
Sstruct
//  Пример дизассемблирования с помощью Compiler Explorer. { int x; };
inline S x1 = S{321}; // mov esi, dword ptr [x1]
                      // x1: .long 321

S x2 = S{123}; // mov eax, dword ptr [.L_ZZ4mainE2x2]
                      // mov dword ptr [rbp - 8], eax
                      // .L_ZZ4mainE2x2: .long 123
```

Его также можно использовать для объявления и определения статической переменной-члена, чтобы её не нужно было инициализировать в исходном файле.

```c
S struct {
 S() : id{count++} {}
 ~S() { count--; }
 int id;
 static inline int count{0}; // объявить и инициализировать count значением 0 внутри класса
};
```

### Структурированные привязки

Предложение по деструктуризации инициализации, которое позволит писать `auto [ x, y, z ] = expr;` там, где тип `expr` является кортежеподобным объектом, элементы которого будут привязаны к переменным `x`, `y`, и `z` (которые объявляются в этой конструкции). _Кортежеподобные объекты_ включают в себя [`std::tuple`](https://github.com/AnthonyCalandra/modern-cpp-features/blob/master/README.md#tuples), `std::pair`, [`std::array`](https://github.com/AnthonyCalandra/modern-cpp-features/blob/master/README.md#stdarray), а также агрегатные структуры.

```c
using Coordinate = std::pair<int, int>;
Coordinate origin() {
 return Coordinate{0, 0};
}

const auto [ x, y ] = origin();
x; // == 0
y; // == 0
```

```c
std::unordered_map<std::string, int> mapping {
 {"a", 1},
 {"b", 2},
 {"c", 3}
};

// Деструктуризация по ссылке.
for (const auto& [key, value] : mapping) {
 // Сделайте что-нибудь с ключом и значением
}
```

### Операторы выбора с инициализатором

Новые версии операторов `if` и `switch` упрощают распространённые шаблоны кода и помогают пользователям сохранять область видимости.

```c
{
 std::lock_guard<std::mutex> lk(mx);
 if (v.empty()) v.push_back(val);
}
// vs.
if (std::lock_guard<std::mutex> lk(mx); v.empty()) {
 v.push_back(val);
}
```

### constexpr , если

Напишите код, который создаётся в зависимости от условия, определяемого во время компиляции.

```c
шаблон <тип_данных T>
constexpr bool isIntegral() {
 if constexpr (std::is_integral<T>::value) {
 return true;
 } else {
 return false;
 }
}
static_assert(isIntegral<int>() == true);
static_assert(isIntegral<char>() == true);
static_assert(isIntegral<double>() == false);
struct S {};
static_assert(isIntegral<S>() == false);
```

### Атрибуты [[fallthrough]], [[nodiscard]], [[maybe_unused]]

В C++17 появились три новых атрибута: `[[fallthrough]]`, `[[nodiscard]]` и `[[maybe_unused]]`.

- `[[fallthrough]]` указывает компилятору, что пропуск в операторе switch является ожидаемым поведением. Этот атрибут можно использовать только в операторе switch, и он должен располагаться перед следующей меткой case/default.

```c
switch (n) {
 case 1: 
 // ...
 [[fallthrough]];
 case 2:
 // ...
    break;
 case 3:
 // ...
 [[fallthrough]];
 default:
 // ...
}
```

- `[[nodiscard]]` выдаёт предупреждение, если у функции или класса есть этот атрибут, а его возвращаемое значение игнорируется.

```c
[[nodiscard]] bool do_something() {
 return is_success; // true в случае успеха, false в случае неудачи
}

do_something(); // предупреждение: игнорируется возвращаемое значение 'bool do_something()',
                // объявленное с атрибутом 'nodiscard'
```

```c
// Only issues a warning when `error_info` is returned by value.
struct [[nodiscard]] error_info {
  // ...
};

error_info do_something() {
  error_info ei;
  // ...
  return ei;
}

do_something(); // warning: ignoring returned value of type 'error_info',
                // declared with attribute 'nodiscard'
```

- `[[maybe_unused]]` indicates to the compiler that a variable or parameter might be unused and is intended.

```c
void my_callback(std::string msg, [[maybe_unused]] bool error) {
  // Don't care if `msg` is an error message, just log it.
  log(msg);
}
```


### Вывод аргумента шаблона класса

_Вывод аргументов шаблона класса_ (CTAD) позволяет компилятору выводить аргументы шаблона из аргументов конструктора.

```c
std::vector v{ 1, 2, 3 }; // выводит тип std::vector<int>

std::mutex mtx;
auto lck = std::lock_guard{ mtx }; // преобразуется в std::lock_guard<std::mutex>

auto p = new std::pair{ 1.0, 2.0 }; // преобразуется в std::pair<double, double>*
```

Для пользовательских типов можно использовать _руководства по выводу_, чтобы подсказать компилятору, как выводить аргументы шаблона, если это применимо:
```cpp
template <typename T>
struct container {
  container(T t) {}

  template <typename Iter>
  container(Iter beg, Iter end);
};

// deduction guide
template <typename Iter>
container(Iter b, Iter e) -> container<typename std::iterator_traits<Iter>::value_type>;

container a{ 7 }; // OK: deduces container<int>

std::vector<double> v{ 1.0, 2.0, 3.0 };
auto b = container{ v.begin(), v.end() }; // OK: deduces container<double>

container c{ 5, 6 }; // ERROR: std::iterator_traits<int>::value_type is not a type
```